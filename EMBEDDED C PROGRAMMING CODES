# Projects
________________________________________________________________________________________________________________________________-
1.SMART PARKING:
#include "mbed.h"

// ---- Hardware Declarations ----
DigitalIn IR1(PC_0);      // IR Sensor 1 (Entrance)
DigitalIn IR2(PC_1);      // IR Sensor 2 (Exit)
PwmOut servo(PB_0);       // Servo Motor control pin
DigitalOut buzzer(PC_6);  // Buzzer for "Parking Full"

// 7-Segment Display pins (Common Anode or Cathode based)
BusOut seg(PA_0, PA_1, PA_4, PB_0, PB_4, PC_0, PC_1); // a,b,c,d,e,f,g 

// ---- Global Variables ----
int totalSlots = 7;    // Maximum parking slots
int availableSlots = 7; // Starts full
int prevIR1 = 0, prevIR2 = 0; // Used for detecting entry/exit sequence

// ---- Hex Codes for 7-Segment (Common Anode) ----
int segCode[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};

// ---- Function to Display Number on 7-Segment ----
void displayNumber(int num) {
    seg = segCode[num];
}

// ---- Function to Control Servo Gate ----
void openGate() {
    servo.period_ms(20);           // Standard 50 Hz servo
    servo.pulsewidth_us(1500);     // 90° position
    wait(5);                       // Gate open for 5 seconds
    servo.pulsewidth_us(500);      // Back to 0° (closed)
}

// ---- Main Program ----
int main() {
    servo.period_ms(20);
    servo.pulsewidth_us(500);  // Initially gate closed
    buzzer = 0;                // Buzzer off
    displayNumber(availableSlots);

    while(1) {
        int IR1_state = IR1.read();
        int IR2_state = IR2.read();

        // ---- Vehicle Entry (IR1 → IR2) ----
        if (IR1_state == 1 && prevIR1 == 0) { wait(0.2); prevIR1 = 1; }
        if (IR2_state == 1 && prevIR1 == 1) {
            // Vehicle entering
            if (availableSlots > 0) {
                openGate();
                availableSlots--;
                if (availableSlots < 0) availableSlots = 0;
                displayNumber(availableSlots);
            } else {
                // Parking full
                buzzer = 1;
                wait(5);
                buzzer = 0;
            }
            prevIR1 = 0;
        }

        // ---- Vehicle Exit (IR2 → IR1) ----
        if (IR2_state == 1 && prevIR2 == 0) { wait(0.2); prevIR2 = 1; }
        if (IR1_state == 1 && prevIR2 == 1) {
            // Vehicle exiting
            if (availableSlots < totalSlots) {
                openGate();
                availableSlots++;
                if (availableSlots > totalSlots) availableSlots = totalSlots;
                displayNumber(availableSlots);
            }
            prevIR2 = 0;
        }

        wait(0.1);
    }
}

___________________________________________________________________________________________________________________________________________
2.COUNTDOWN
#include "mbed.h"
#include "TextLCD.h"
#include "keypad.h"
DigitalOut buzz(PC_8);
Keypad key(PA_10, PB_3, PB_5, PB_4, PB_10, PA_8, PA_9, PC_7);
TextLCD lcd(PC_0, PC_1, PB_0, PA_4, PA_1, PA_0);
int main(){
    key.enablePullUp();
    lcd.locate(0,0);
    lcd.printf("Enter value");
    while(1){
        int a, b, c;
        while(key.getKey()=='\0');
        a = key.getKey();
        while(key.getKey()=='\0');
        b = key.getKey();
        c= a*10 + b;5
        lcd.locate(0,1);
        lcd.printf("%c seconds",c);
        for (int i = c; i>=0; i--){
            c--;
            lcd.locate(0,1);
            lcd.printf("%c seconds",c);
        }
        if (c==0){
            buzz=1;
            wait(2);
        }
        else{
            buzz=0;
        }
    }
}

__________________________________________________________________________________________________________________________________________________________________-
3.SERVO LDR LCD 


#include "mbed.h"
#include "TextLCD.h"

PwmOut servo(PC_8);                       // Servo Motor
AnalogIn LDR_L(PA_0);                     // Left LDR
AnalogIn LDR_R(PA_1);                     // Right LDR
TextLCD lcd(PC_0, PC_1, PB_0, PB_4, PA_1, PA_0); // RS, E, D4, D5, D6, D7

int main() {
    float angle = 90;                     // Start position
    servo.period_ms(20);                  // Servo frequency 50Hz

    while(1) {
        float left  = LDR_L.read();
        float right = LDR_R.read();

        if(left - right > 0.02) angle += 5;     // Move Left
        else if(right - left > 0.02) angle -= 5; // Move Right

        if(angle < 0) angle = 0;
        if(angle > 180) angle = 180;

        servo.pulsewidth_us(500 + angle * 2000 / 180); // Servo control

        // Display LDR values and Servo angle
        lcd.locate(0,0);
        lcd.printf("L:%.2f R:%.2f", left, right);
        lcd.locate(0,1);
        lcd.printf("Angle:%3d", (int)angle);

        wait(0.2);
    }
}

_____________________________________________________________________________________________________________________________
Restaurant Ordering System with SPI Kitchen Display

#include "mbed.h"
#include "keypad.h"
#include "TextLCD.h"

// Keypad + LCD + Bluetooth + SPI Integration
Serial bt(PC_10, PC_11);  // Bluetooth: TX, RX
TextLCD lcd(PC_0, PC_1, PB_0, PA_4, PA_1, PA_0); // RS, E, D4-D7
Keypad kpad(PA_10, PB_3, PB_5, PB_4, PB_10, PA_8, PA_9, PC_7); // C1-C4, R1-R4
SPI kitchenDisplay(PB_15, PB_14, PB_13); // MOSI, MISO, SCLK
DigitalOut cs(PB_12); // Chip Select for SPI

// Menu prices
int menu_prices[4] = {300, 150, 200, 50}; // Pizza, Burger, Pasta, Coke

int main() {
    bt.baud(9600);
    kitchenDisplay.format(8, 0); // 8-bit data, Mode 0
    kitchenDisplay.frequency(1000000); // 1MHz SPI
    cs = 1; // Start with CS high
    
    lcd.printf("RESTAURANT ORDER");
    wait(2);
    
    while(1) {
        int table_no = 0, item_code = 0, quantity = 0;
        char input;
        
        // Get table number
        lcd.cls();
        lcd.printf("Table No: ");
        while(!(input = kpad.getKey()));
        table_no = input - '0';
        lcd.printf("%d", table_no);
        wait(1);
        
        // Get item code
        lcd.cls();
        lcd.printf("Item Code: ");
        while(!(input = kpad.getKey()));
        item_code = input - '0';
        lcd.printf("%d", item_code);
        wait(1);
        
        // Get quantity
        lcd.cls();
        lcd.printf("Quantity: ");
        while(!(input = kpad.getKey()));
        quantity = input - '0';
        lcd.printf("%d", quantity);
        wait(1);
        
        // Calculate total
        int total = menu_prices[item_code-1] * quantity;
        
        // Display on LCD
        lcd.cls();
        lcd.printf("Total: Rs.%d", total);
        
        // Send to Smartphone via Bluetooth
        bt.printf("=== ORDER RECEIVED ===\r\n");
        bt.printf("Table: %d\r\n", table_no);
        bt.printf("Item: %d\r\n", item_code);
        bt.printf("Qty: %d\r\n", quantity);
        bt.printf("Total: Rs.%d\r\n", total);
        bt.printf("=====================\r\n");
        
        // Send to Kitchen Display via SPI
        cs = 0; // Select kitchen display
        kitchenDisplay.write(table_no); // Send table number
        kitchenDisplay.write(item_code); // Send item code  
        kitchenDisplay.write(quantity); // Send quantity
        cs = 1; // Deselect
        
        lcd.cls();
        lcd.printf("Order Sent!");
        lcd.locate(0,1);
        lcd.printf("Wait 5 sec...");
        wait(5);
        
        lcd.cls();
        lcd.printf("New Order?");
        lcd.locate(0,1);
        lcd.printf("Press any key");
        while(!kpad.getKey()); // Wait for key press
    }
}
__________________________________________________________________________________________________________________________


Seed sowing 
We are given a problem to design a line follower seed sowing bot using an STM32 Nucleo board with the following components:

LM35 temperature sensor

Buzzer

Two servo motors (one for sowing arm and one for pump)

IR sensor (for line following)

7-segment display (common anode)

The bot should:

Continuously monitor soil temperature using LM35.

Sow a seed only if the soil temperature is below 25°C. If the temperature exceeds 25°C, activate the pump (by rotating the pump servo to 90°) for two minutes.

The bot must follow a black field with white vertical lines. The IR sensor is used to check if the bot is on the path. If it deviates, trigger the buzzer.

The sowing is done by rotating the sowing servo to 180° at two-second intervals.

The 7-segment display should increment the count by one each time a seed is planted, and the maximum seed count is 9.
#include "mbed.h"

// Sensors & Actuators
AnalogIn tempSensor(PC_3);          // LM35 Temperature
DigitalIn irSensor(PC_8);           // IR Line Sensor
DigitalOut buzzer(PC_10);           // Buzzer
PwmOut sowingServo(PA_0);           // Seed sowing servo
PwmOut pumpServo(PA_1);             // Water pump servo

// 7-Segment Display Pins (Common Anode)
DigitalOut segA(PB_0);
DigitalOut segB(PB_1);
DigitalOut segC(PB_2);
DigitalOut segD(PB_3);
DigitalOut segE(PB_4);
DigitalOut segF(PB_5);
DigitalOut segG(PB_6);

// Global Variables
int seedCount = 0;
bool sowingEnabled = true;

// 7-Segment Display Patterns (Common Anode - ACTIVE LOW)
const bool digitPatterns[10][7] = {
    {0,0,0,0,0,0,1}, // 0
    {1,0,0,1,1,1,1}, // 1
    {0,0,1,0,0,1,0}, // 2
    {0,0,0,0,1,1,0}, // 3
    {1,0,0,1,1,0,0}, // 4
    {0,1,0,0,1,0,0}, // 5
    {0,1,0,0,0,0,0}, // 6
    {0,0,0,1,1,1,1}, // 7
    {0,0,0,0,0,0,0}, // 8
    {0,0,0,0,1,0,0}  // 9
};

// Function to update 7-segment display
void updateDisplay(int number) {
    if (number < 0 || number > 9) return;
    
    segA = digitPatterns[number][0];
    segB = digitPatterns[number][1];
    segC = digitPatterns[number][2];
    segD = digitPatterns[number][3];
    segE = digitPatterns[number][4];
    segF = digitPatterns[number][5];
    segG = digitPatterns[number][6];
}

// Function to control servo positions
void setServoAngle(PwmOut &servo, float angle) {
    // Convert angle (0-180) to PWM pulse width (0.001 to 0.002)
    float pulseWidth = 0.001f + (angle / 180.0f) * 0.001f;
    servo.pulsewidth(pulseWidth);
}

// Function to read temperature from LM35
float readTemperature() {
    // LM35: 10mV/°C, Vref = 3.3V
    float voltage = tempSensor.read() * 3.3f;
    float temperature = voltage * 100.0f; // 10mV/°C = 100°C/V
    return temperature;
}

// Function to sow a seed
void sowSeed() {
    if (seedCount >= 9) {
        sowingEnabled = false;
        return;
    }
    
    setServoAngle(sowingServo, 180.0f); // Move to sow position
    wait(2.0);                          // Wait 2 seconds
    setServoAngle(sowingServo, 0.0f);   // Return to rest position
    
    seedCount++;                        // Increment seed count
    updateDisplay(seedCount);           // Update display
}

// Function to activate water pump
void activatePump() {
    setServoAngle(pumpServo, 90.0f);    // Activate pump
    wait(120.0);                        // Run for 2 minutes
    setServoAngle(pumpServo, 0.0f);     // Return to rest position
}

int main() {
    // Initialize servo period (20ms = 50Hz)
    sowingServo.period(0.02f);
    pumpServo.period(0.02f);
    
    // Initialize servos to rest position
    setServoAngle(sowingServo, 0.0f);
    setServoAngle(pumpServo, 0.0f);
    
    // Initialize display
    updateDisplay(0);
    
    while(1) {
        // Read soil temperature
        float temperature = readTemperature();
        
        // Check if temperature is too high
        if (temperature > 25.0f) {
            activatePump();
            sowingEnabled = false; // Stop sowing while watering
        } else {
            sowingEnabled = true;  // Resume sowing
        }
        
        // Check line following with IR sensor
        // IR sensor gives 0 on black line, 1 on white deviation
        if (irSensor.read() == 1) {
            // Bot deviated from path
            buzzer = 1; // Activate buzzer
            sowingEnabled = false; // Stop sowing
        } else {
            // Bot on correct path
            buzzer = 0; // Turn off buzzer
            sowingEnabled = true; // Allow sowing
        }
        
        // Sow seed if conditions are met
        if (sowingEnabled && seedCount < 9) {
            sowSeed();
        }
        
        wait(0.1); // Small delay for stability
    }
}                          
______________________________________________________________________________________________________________________________________
